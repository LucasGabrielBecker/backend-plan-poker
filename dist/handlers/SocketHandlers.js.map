{
  "version": 3,
  "sources": ["../../src/handlers/SocketHandlers.ts"],
  "sourcesContent": ["import EVENTS from '../eventsEnum'\nimport { v4 } from 'uuid'\nimport { Room } from '../Schemas'\nimport { UsersVoted, User } from '../types/types'\nconst connectedClients = new Map<string, User>()\nlet cards = [\n\t{\n\t\tid: v4(),\n\t\ttitle: 'Primeiro Card',\n\t\tdescription: 'Some description would go here',\n\t\tvoting: false,\n\t\tvotes: []\n\t},\n\t{\n\t\tid: v4(),\n\t\ttitle: 'Segundo Card',\n\t\tdescription: 'Some description would go here',\n\t\tvoting: true,\n\t\tvotes: []\n\t}\n]\n\nlet voted: UsersVoted[] = []\n\nexport const getCards = socket => {\n\tsocket.emit(EVENTS.UPDATE_CARDS, {\n\t\tcards,\n\t\tconnectedClients: parseConnectedClients()\n\t})\n}\n\nexport const register = (socket, payload) => {\n\tconnectedClients.set(payload.id, payload)\n\tsocket.emit(EVENTS.NEW_CLIENT, {\n\t\tnewUser: payload.username,\n\t\tconnectedClients: parseConnectedClients()\n\t})\n}\n\nexport const getConnectedClients = () => {\n\treturn parseConnectedClients()\n\t// socket.emit(EVENTS.CONNECTED_CLIENTS, parseConnectedClients());\n}\n\nexport const setVotingCard = async (socket, payload) => {\n\tconst { cardId, room } = payload\n\tconst dbRoom = await Room.findOne({ name: room }).populate('cards')\n\n\tsocket.emit(\n\t\tEVENTS.NEW_VOTING_CARD,\n\t\tdbRoom.cards.find(card => card._id.toString() === cardId)\n\t)\n}\n\nexport const notifyUserDisconnect = (socketId): User => {\n\tif (!socketId) return\n\tconst users = parseConnectedClients()\n\tconst disconnectedUser = users.find(u => u.socketId === socketId)\n\tif (!disconnectedUser) return\n\tconnectedClients.delete(disconnectedUser.id)\n\treturn disconnectedUser\n}\n\nexport const handleVote = async (socket, payload) => {\n\tconsole.log(payload)\n\tconst { userId, points, cardId } = payload\n\tvoted.push({ id: userId, cardId, points })\n\tconst user = connectedClients.get(userId)\n\tconnectedClients.set(userId, { ...user, points })\n\n\tsocket.emit(EVENTS.UPDATE_USERS, {\n\t\tusers: parseConnectedClients(),\n\t\tusersAlreadyVoted: voted.map(u => u.id)\n\t})\n}\n\nexport const parseConnectedClients = () =>\n\tArray.from(connectedClients, ([item, value]) => ({ ...value }))\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAmB;AACnB,kBAAmB;AACnB,qBAAqB;AAErB,MAAM,mBAAmB,oBAAI;AAC7B,IAAI,QAAQ;AAAA,EACX;AAAA,IACC,IAAI;AAAA,IACJ,OAAO;AAAA,IACP,aAAa;AAAA,IACb,QAAQ;AAAA,IACR,OAAO;AAAA;AAAA,EAER;AAAA,IACC,IAAI;AAAA,IACJ,OAAO;AAAA,IACP,aAAa;AAAA,IACb,QAAQ;AAAA,IACR,OAAO;AAAA;AAAA;AAIT,IAAI,QAAsB;AAEnB,MAAM,WAAW,YAAU;AACjC,SAAO,KAAK,0BAAO,cAAc;AAAA,IAChC;AAAA,IACA,kBAAkB;AAAA;AAAA;AAIb,MAAM,WAAW,CAAC,QAAQ,YAAY;AAC5C,mBAAiB,IAAI,QAAQ,IAAI;AACjC,SAAO,KAAK,0BAAO,YAAY;AAAA,IAC9B,SAAS,QAAQ;AAAA,IACjB,kBAAkB;AAAA;AAAA;AAIb,MAAM,sBAAsB,MAAM;AACxC,SAAO;AAAA;AAID,MAAM,gBAAgB,CAAO,QAAQ,YAAY;AACvD,QAAM,EAAE,QAAQ,SAAS;AACzB,QAAM,SAAS,MAAM,oBAAK,QAAQ,EAAE,MAAM,QAAQ,SAAS;AAE3D,SAAO,KACN,0BAAO,iBACP,OAAO,MAAM,KAAK,UAAQ,KAAK,IAAI,eAAe;AAAA;AAI7C,MAAM,uBAAuB,CAAC,aAAmB;AACvD,MAAI,CAAC;AAAU;AACf,QAAM,QAAQ;AACd,QAAM,mBAAmB,MAAM,KAAK,OAAK,EAAE,aAAa;AACxD,MAAI,CAAC;AAAkB;AACvB,mBAAiB,OAAO,iBAAiB;AACzC,SAAO;AAAA;AAGD,MAAM,aAAa,CAAO,QAAQ,YAAY;AACpD,UAAQ,IAAI;AACZ,QAAM,EAAE,QAAQ,QAAQ,WAAW;AACnC,QAAM,KAAK,EAAE,IAAI,QAAQ,QAAQ;AACjC,QAAM,OAAO,iBAAiB,IAAI;AAClC,mBAAiB,IAAI,QAAQ,iCAAK,OAAL,EAAW;AAExC,SAAO,KAAK,0BAAO,cAAc;AAAA,IAChC,OAAO;AAAA,IACP,mBAAmB,MAAM,IAAI,OAAK,EAAE;AAAA;AAAA;AAI/B,MAAM,wBAAwB,MACpC,MAAM,KAAK,kBAAkB,CAAC,CAAC,MAAM,WAAY,mBAAK;",
  "names": []
}
